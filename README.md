# HighLoad Homework Social Network

Проект учебной социальной сети для курса "Архитектор высоких нагрузок".

## Запуск проекта

1.  Убедитесь, что у вас установлен Docker и Docker Compose.
2.  **Важно:** Создайте пустые папки `initdb-counters`, `initdb-dialogs`, `initdb-master`, `initdb-posts`, `postgres-data`, `redis-scripts`, `reports` в корне проекта, если они отсутствуют.
3.  Скопируйте предоставленные SQL-скрипты инициализации в соответствующие папки `initdb-*`.
    *   В `initdb-counters` должен быть скрипт для создания таблицы `counters`.
    *   В `initdb-dialogs` должен быть скрипт для создания таблицы `messages`.
    *   В `initdb-master` должен быть скрипт для создания таблиц основного сервиса (users, friends и т.д.).
    *   В `initdb-posts` должен быть скрипт для создания таблицы `posts`.
4.  В папке `redis-scripts` должен быть файл `redis_functions.lua` (если используется Redis Functions для DialogService).
5.  Выполните команду в корне проекта:
    ```bash
    docker compose up --build -d
    ```
    Ключ `--build` пересобирает образы, `-d` запускает контейнеры в фоновом режиме.

## Доступные сервисы

*   **Основное приложение (Nginx)**: `http://localhost` (порт 80)
    *   Балансирует нагрузку между двумя экземплярами `highload.homework.socialnetwork`.
*   **PostService**: `http://localhost:8090`
    *   Управляет постами и лентой новостей.
    *   База данных: `postdb` (PostgreSQL) на порту `5435`.
*   **DialogService**: `http://localhost:8100`
    *   Управляет диалогами и сообщениями.
    *   Публикует события о новых/прочитанных сообщениях в RabbitMQ.
    *   База данных: `citus-coordinator` (Citus/PostgreSQL) на порту `5436`.
*   **CounterService**: `http://localhost:8110`
    *   Предоставляет счетчики (например, непрочитанных сообщений).
    *   Подписывается на события из RabbitMQ.
    *   База данных: `counter-db` (PostgreSQL) на порту `5439`.
    *   Кэш: `redis` на порту `6380`.
*   **RabbitMQ Management UI**: `http://localhost:15673` (логин: `rabbitmq`, пароль: `rabbitmq`)
*   **Grafana**: `http://localhost:3000`
*   **Prometheus**: `http://localhost:9090`

## Архитектура

Проект построен на основе микросервисной архитектуры.

*   **Основной сервис:** Реализует базовую функциональность (регистрация, аутентификация, профили, друзья).
*   **PostService:** Вынесенная функциональность постов и ленты.
*   **DialogService:** Вынесенная функциональность диалогов.
*   **CounterService:** Вынесенная функциональность подсчета различных метрик (например, непрочитанных сообщений).

### Подсчет непрочитанных сообщений

Для подсчета непрочитанных сообщений используется паттерн **событийной согласованности** (Eventual Consistency) с использованием брокера сообщений RabbitMQ.

Подробное описание архитектуры и схема взаимодействия находятся в отчете: [reports/unread_messages_architecture.md](reports/unread_messages_architecture.md).

## Базы данных

*   **Основной сервис:** PostgreSQL с репликацией (master-db, slave1-db, slave2-db), балансировка чтения через HAProxy.
*   **PostService:** Отдельная база данных PostgreSQL (`postdb`).
*   **DialogService:** Отдельная база данных Citus/PostgreSQL (`citus-coordinator`, `citus-worker1`, `citus-worker2`).
*   **CounterService:** Отдельная база данных PostgreSQL (`counter-db`).

## Кэширование

*   **CounterService:** Использует Redis для кэширования значений счетчиков.

## Нагрузочное тестирование

Для проведения нагрузочного тестирования используется K6. Скрипты находятся в папке `k6-scripts`.

# Инструкция по запуску приложения и выполнению нагрузочного тестирования

# Примечание

Отчёты о проделанной работе хранятся в папке reports

## Описание конфигурации

`docker-compose.yml` определяет инфраструктуру с сервисами:

- **Prometheus (9090)**: сбор метрик.
- **Grafana (3000)**: визуализация метрик и дашборды.
- **PostgreSQL мастер (5432)**: основная база данных для записей.
- **Инициализация репликационных слотов (init-slots)**: создаёт слоты репликации для слейвов после того, как мастер станет доступен.
- **PostgreSQL slave1 (5433) и slave2 (5434)**: слейвы, реплицирующие данные от мастера. Используются для чтения.
- **Сервис пользователей (8080)**: собственно ваш сервис, подключенный к мастеру и двум слейвам. Запросы на чтение направляются на слейвы, на запись — на мастер.
- **K6**: инструмент для нагрузочного тестирования.
- **Сервис постов (8090)**: сервис, который управляет постами и дружбой.
- **База данных постов (5435)**: база PostgreSQL для PostService, инициализируемая скриптами при первом запуске.
- **Координатор Citus (5436)**: база PostgreSQL с плагином Citus для шардинга для DialogService, инициализируемая скриптами при первом запуске, данный хост настраивается как координатор
- **Воркер-1 Citus (5437)**: база PostgreSQL с плагином Citus для шардинга для DialogService, инициализируемая скриптами при первом запуске, данный хост настраивается как первый воркер
- **Воркер-2 Citus (5438)**: база PostgreSQL с плагином Citus для шардинга для DialogService, инициализируемая скриптами при первом запуске, данный хост настраивается как первый воркер
- **Сервис диалогов(8100)**: сервис, который управляет диалогами
- **RabbitMQ(5673)**: шина данных RabbitMQ


## Запуск инфраструктуры

1. Убедитесь, что у вас установлен Docker и Docker Compose.
2. Клонируйте репозиторий или поместите `docker-compose.yml` и необходимые папки (`prometheus`, `grafana`, `initdb-master`, `k6-scripts`, `initdb-post`, `initdb-dialogs`) в одну директорию.
3. Запустите все сервисы:
   ```bash
   docker compose up -d
   ```

Это развернёт Prometheus, Grafana, мастер и слейвы PostgreSQL, а также ваше приложение.

## Проверка статуса и доступ

- Приложение пользователей доступно на порту `8080`:
  ```
  http://localhost:8080
  ```

- Prometheus доступен на порту `9090`:
  ```
  http://localhost:9090
  ```

- Grafana доступна на порту `3000`:
  ```
  http://localhost:3000
  ```
  Гостевой доступ включён, вы сразу увидите дашборды и сможете наблюдать метрики.

## Нагрузочное тестирование

Для нагрузки используются скрипты в папке `k6-scripts`. Предположим, что там лежат два скрипта:

- `load-test.js` — для нагрузки на чтение (обращения к слейвам).
- `load-write-test.js` — для нагрузки на запись (обращения к мастеру).

Выполните нагрузку на чтение:
```bash
docker compose run k6 run /scripts/load-test.js
```

Выполните нагрузку на запись:
```bash
docker compose run k6 run /scripts/load-write-test.js
```

При запуске этих команд будут созданы временные контейнеры для `k6`, которые выполнят нагрузочный тест, используя соответствующие скрипты.

## Остановка и очистка

Для остановки всех сервисов выполните:
```bash
docker compose down
```

Это остановит и удалит контейнеры, но сохранит данные в томах (`./postgres-data`), если вы захотите сохранить состояние базы.

Если хотите полностью очистить данные, удалите или очистите соответствующие директории с данными вручную.

# Сервис пользователей (Документация по запросам к API)

## Аутентификация

### POST `/v1/auth/login`
Позволяет аутентифицировать пользователя. При успешной аутентификации возвращает JWT-токен, который необходимо использовать в заголовке `Authorization: Bearer <token>` при дальнейших запросах.

Пример запроса:
```bash
curl -X POST http://localhost:8080/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"user@example.com","password":"SuperSecurePassword"}'
```

### POST `/v1/auth/register`
Регистрация нового пользователя. Ожидает данные о пользователе (например, email и пароль) и создаёт запись в базе данных.

Пример запроса:
```bash
curl -X POST http://localhost:8080/auth/register \
  -H "Content-Type: application/json" \
  -d '{
  "firstName": "string",
  "lastName": "string",
  "dateOfBirth": "2024-12-18T05:41:24.965Z",
  "gender": "string",
  "interests": "string",
  "city": "string",
  "email": "string",
  "password": "string"
}'
```

### POST `/v1/auth/generate-users`
Генерирует тестовых пользователей. Принимает параметр `count` (целое число), определяющий, сколько пользователей будет сгенерировано.

Параметры:
- `count`: целое число (query parameter), количество пользователей для генерации.

Пример запроса:
```bash
curl -X POST "http://localhost:8080/auth/generate-users?count=10"
```

## Пользователи

### GET `/v1/users/{id}`
Возвращает информацию о пользователе с указанным идентификатором (UUID или иной уникальный идентификатор).

Пример запроса:
```bash
curl -X GET http://localhost:8080/users/000074ac-8a22-450f-a836-d730cd8c2a00 \
  -H "Authorization: Bearer <token>"
```

### GET `/v1/users/search`
Позволяет искать пользователей по определённым критериям, например по имени и фамилии.

Пример запроса:
```bash
curl -X GET "http://localhost:8080/users/search?firstName=Al&lastName=Jo" \
  -H "Authorization: Bearer <token>"
```


# Сервис постов (Документация по запросам к API)

## 1. URL сервиса и токен

- Сервис постов:
  ```
  http://localhost:8090
  ```
- Большинство методов требуют JWT-токен (получается в основном сервисе `http://localhost:8080/auth/login`):
  ```
  Authorization: Bearer <YOUR_TOKEN>
  ```

## 2. Создание друзей (FriendsController)

### 2.1 Добавить друга
`POST /friends?userId=<GUID>&friendId=<GUID>`

- Создаёт дружбу между двумя пользователями.

### 2.2 Удалить друга
`DELETE /friends?userId=<GUID>&friendId=<GUID>`

- Удаляет дружбу между двумя пользователями.

### 2.3 Сгенерировать друзей
`POST /friends/generate?totalFriendships=<число>&friendsPerUser=<число>`

- Случайно создаёт заданное количество дружб между уже существующими пользователями.
- Параметры:
    - `totalFriendships` — общее число дружб.
    - `friendsPerUser` — сколько примерно друзей на одного пользователя.

## 3. Посты (PostsController)

### 3.1 Получить пост
`GET /posts/{id}`

- Возвращает пост по идентификатору.

### 3.2 Создать пост
`POST /posts`  
Тело (JSON):
```json
{
  "authorId": "<GUID>",
  "content": "Текст поста"
}
```

### 3.3 Обновить пост
`PUT /posts/{id}`

### 3.4 Удалить пост
`DELETE /posts/{id}`

### 3.5 Лента постов
`GET /posts/feed/{userId}`

- Возвращает последние посты друзей пользователя с `userId`.

### 3.6 Пересобрать кэш ленты
`POST /posts/feed/rebuild/{userId}`

- Сбрасывает кэш ленты и заново подгружает посты друзей.

### 3.7 Сгенерировать посты
`POST /posts/generate?totalPosts=<число>&maxPostsPerUser=<число>`

- Случайно создаёт указанное число постов для разных пользователей.
    - `totalPosts` — общее число постов.
    - `maxPostsPerUser` — сколько максимум постов на одного пользователя за раз.

### 3.8 Эндпоинт для вебсокета (получение постов друзей)
`ws://localhost:8090/post/feed/posted`


# Сервис диалогов (Документация по запросам к API)

Необходимо авторизироваться под кем-то, от лица этого пользователя и будут отправляться сообщения

Методы API:
    - `POST /dialog/{userId}/send`: отправка сообщения;
    - `GET /dialog/{userId}/list?receiverId={receiverId}`: получить диалог

Сервис использует инструмент Citus для шардирования

---

Все запросы к защищённым ресурсам (например, получение списка пользователей или поиск) требуют наличия заголовка `Authorization` с корректным JWT-токеном, полученным после успешного входа через `/auth/login`.



