
# Инструкция по запуску приложения и выполнению нагрузочного тестирования

# Примечание

Отчёты о проделанной работе хранятся в папке reports

## Описание конфигурации

`docker-compose.yml` определяет инфраструктуру с сервисами:

- **Prometheus (9090)**: сбор метрик.
- **Grafana (3000)**: визуализация метрик и дашборды.
- **PostgreSQL мастер (5432)**: основная база данных для записей.
- **Инициализация репликационных слотов (init-slots)**: создаёт слоты репликации для слейвов после того, как мастер станет доступен.
- **PostgreSQL slave1 (5433) и slave2 (5434)**: слейвы, реплицирующие данные от мастера. Используются для чтения.
- **Сервис пользователей (8080)**: собственно ваш сервис, подключенный к мастеру и двум слейвам. Запросы на чтение направляются на слейвы, на запись — на мастер.
- **K6**: инструмент для нагрузочного тестирования.
- **Сервис постов (8090)**: сервис, который управляет постами и дружбой.
- **База данных постов (5435)**: база PostgreSQL для PostService, инициализируемая скриптами при первом запуске.
- **Координатор Citus (5436)**: база PostgreSQL с плагином Citus для шардинга для DialogService, инициализируемая скриптами при первом запуске, данный хост настраивается как координатор
- **Воркер-1 Citus (5437)**: база PostgreSQL с плагином Citus для шардинга для DialogService, инициализируемая скриптами при первом запуске, данный хост настраивается как первый воркер
- **Воркер-2 Citus (5438)**: база PostgreSQL с плагином Citus для шардинга для DialogService, инициализируемая скриптами при первом запуске, данный хост настраивается как первый воркер
- **Сервис диалогов(8100)**: сервис, который управляет диалогами
- **RabbitMQ(5673)**: шина данных RabbitMQ


## Запуск инфраструктуры

1. Убедитесь, что у вас установлен Docker и Docker Compose.
2. Клонируйте репозиторий или поместите `docker-compose.yml` и необходимые папки (`prometheus`, `grafana`, `initdb-master`, `k6-scripts`, `initdb-post`, `initdb-dialogs`) в одну директорию.
3. Запустите все сервисы:
   ```bash
   docker compose up -d
   ```

Это развернёт Prometheus, Grafana, мастер и слейвы PostgreSQL, а также ваше приложение.

## Проверка статуса и доступ

- Приложение пользователей доступно на порту `8080`:
  ```
  http://localhost:8080
  ```

- Prometheus доступен на порту `9090`:
  ```
  http://localhost:9090
  ```

- Grafana доступна на порту `3000`:
  ```
  http://localhost:3000
  ```
  Гостевой доступ включён, вы сразу увидите дашборды и сможете наблюдать метрики.

## Нагрузочное тестирование

Для нагрузки используются скрипты в папке `k6-scripts`. Предположим, что там лежат два скрипта:

- `load-test.js` — для нагрузки на чтение (обращения к слейвам).
- `load-write-test.js` — для нагрузки на запись (обращения к мастеру).

Выполните нагрузку на чтение:
```bash
docker compose run k6 run /scripts/load-test.js
```

Выполните нагрузку на запись:
```bash
docker compose run k6 run /scripts/load-write-test.js
```

При запуске этих команд будут созданы временные контейнеры для `k6`, которые выполнят нагрузочный тест, используя соответствующие скрипты.

## Остановка и очистка

Для остановки всех сервисов выполните:
```bash
docker compose down
```

Это остановит и удалит контейнеры, но сохранит данные в томах (`./postgres-data`), если вы захотите сохранить состояние базы.

Если хотите полностью очистить данные, удалите или очистите соответствующие директории с данными вручную.

# Сервис пользователей (Документация по запросам к API)

## Аутентификация

### POST `/v1/auth/login`
Позволяет аутентифицировать пользователя. При успешной аутентификации возвращает JWT-токен, который необходимо использовать в заголовке `Authorization: Bearer <token>` при дальнейших запросах.

Пример запроса:
```bash
curl -X POST http://localhost:8080/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"user@example.com","password":"SuperSecurePassword"}'
```

### POST `/v1/auth/register`
Регистрация нового пользователя. Ожидает данные о пользователе (например, email и пароль) и создаёт запись в базе данных.

Пример запроса:
```bash
curl -X POST http://localhost:8080/auth/register \
  -H "Content-Type: application/json" \
  -d '{
  "firstName": "string",
  "lastName": "string",
  "dateOfBirth": "2024-12-18T05:41:24.965Z",
  "gender": "string",
  "interests": "string",
  "city": "string",
  "email": "string",
  "password": "string"
}'
```

### POST `/v1/auth/generate-users`
Генерирует тестовых пользователей. Принимает параметр `count` (целое число), определяющий, сколько пользователей будет сгенерировано.

Параметры:
- `count`: целое число (query parameter), количество пользователей для генерации.

Пример запроса:
```bash
curl -X POST "http://localhost:8080/auth/generate-users?count=10"
```

## Пользователи

### GET `/v1/users/{id}`
Возвращает информацию о пользователе с указанным идентификатором (UUID или иной уникальный идентификатор).

Пример запроса:
```bash
curl -X GET http://localhost:8080/users/000074ac-8a22-450f-a836-d730cd8c2a00 \
  -H "Authorization: Bearer <token>"
```

### GET `/v1/users/search`
Позволяет искать пользователей по определённым критериям, например по имени и фамилии.

Пример запроса:
```bash
curl -X GET "http://localhost:8080/users/search?firstName=Al&lastName=Jo" \
  -H "Authorization: Bearer <token>"
```


# Сервис постов (Документация по запросам к API)

## 1. URL сервиса и токен

- Сервис постов:
  ```
  http://localhost:8090
  ```
- Большинство методов требуют JWT-токен (получается в основном сервисе `http://localhost:8080/auth/login`):
  ```
  Authorization: Bearer <YOUR_TOKEN>
  ```

## 2. Создание друзей (FriendsController)

### 2.1 Добавить друга
`POST /friends?userId=<GUID>&friendId=<GUID>`

- Создаёт дружбу между двумя пользователями.

### 2.2 Удалить друга
`DELETE /friends?userId=<GUID>&friendId=<GUID>`

- Удаляет дружбу между двумя пользователями.

### 2.3 Сгенерировать друзей
`POST /friends/generate?totalFriendships=<число>&friendsPerUser=<число>`

- Случайно создаёт заданное количество дружб между уже существующими пользователями.
- Параметры:
    - `totalFriendships` — общее число дружб.
    - `friendsPerUser` — сколько примерно друзей на одного пользователя.

## 3. Посты (PostsController)

### 3.1 Получить пост
`GET /posts/{id}`

- Возвращает пост по идентификатору.

### 3.2 Создать пост
`POST /posts`  
Тело (JSON):
```json
{
  "authorId": "<GUID>",
  "content": "Текст поста"
}
```

### 3.3 Обновить пост
`PUT /posts/{id}`

### 3.4 Удалить пост
`DELETE /posts/{id}`

### 3.5 Лента постов
`GET /posts/feed/{userId}`

- Возвращает последние посты друзей пользователя с `userId`.

### 3.6 Пересобрать кэш ленты
`POST /posts/feed/rebuild/{userId}`

- Сбрасывает кэш ленты и заново подгружает посты друзей.

### 3.7 Сгенерировать посты
`POST /posts/generate?totalPosts=<число>&maxPostsPerUser=<число>`

- Случайно создаёт указанное число постов для разных пользователей.
    - `totalPosts` — общее число постов.
    - `maxPostsPerUser` — сколько максимум постов на одного пользователя за раз.

### 3.8 Эндпоинт для вебсокета (получение постов друзей)
`ws://localhost:8090/post/feed/posted`


# Сервис диалогов (Документация по запросам к API)

Необходимо авторизироваться под кем-то, от лица этого пользователя и будут отправляться сообщения

Методы API:
    - `POST /dialog/{userId}/send`: отправка сообщения;
    - `GET /dialog/{userId}/list?receiverId={receiverId}`: получить диалог

Сервис использует инструмент Citus для шардирования

---

Все запросы к защищённым ресурсам (например, получение списка пользователей или поиск) требуют наличия заголовка `Authorization` с корректным JWT-токеном, полученным после успешного входа через `/auth/login`.



