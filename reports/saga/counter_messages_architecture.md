# Архитектура подсистемы подсчета сообщений

## 1. Назначение

Подсистема предназначена для отслеживания и предоставления количества непрочитанных сообщений для каждого пользователя в реальном времени. Это позволяет отображать актуальные счетчики в интерфейсе пользователя (например, на иконке сообщений).

## 2. Компоненты

В реализации участвуют следующие компоненты:

-   **DialogService:** Сервис, отвечающий за обработку диалогов и сообщений. Публикует события о новых и прочитанных сообщениях.
-   **CounterService:** Сервис, отвечающий за хранение и предоставление счетчиков. Подписывается на события от `DialogService` и обновляет соответствующие счетчики.
-   **RabbitMQ:** Брокер сообщений, используемый для асинхронного обмена событиями между `DialogService` и `CounterService`.
-   **PostgreSQL (counter-db):** База данных, используемая `CounterService` для постоянного хранения значений счетчиков.
-   **Redis:** Кэш типа "ключ-значение", используемый `CounterService` для быстрого доступа к часто запрашиваемым счетчикам.
-   **MassTransit:** Библиотека .NET для упрощения работы с брокерами сообщений (в данном случае RabbitMQ), используется в обоих сервисах для публикации и подписки на события.


## 3. Описание процесса

1.  **Отправка сообщения:**
    *   Пользователь через клиент отправляет запрос на `DialogService` для создания нового сообщения.
    *   `DialogService` сохраняет сообщение в своей базе данных (Citus).
    *   После успешного сохранения `DialogService` публикует событие `NewMessageEvent` в RabbitMQ, используя MassTransit. Событие направляется в обменник `message-events` с ключом маршрутизации `message.new`.
    *   `CounterService` подписан на очередь `counter-service-new-message`, которая привязана к обменнику `message-events` с ключом `message.new`. Получив событие, `CounterService` увеличивает значение счетчика `UnreadMessages` для получателя сообщения (`RecipientId`) в своей базе данных PostgreSQL (`counter-db`).
    *   `CounterService` также инвалидирует (удаляет) кэш со списком всех счетчиков для данного пользователя в Redis, чтобы при следующем запросе списка счетчиков он был получен из актуального состояния БД.

2.  **Чтение сообщения:**
    *   Пользователь через клиент отправляет запрос на `DialogService` (например, `POST /dialogs/read-batch`), чтобы пометить одно или несколько сообщений как прочитанные.
    *   `DialogService` обновляет статус сообщений в своей базе данных.
    *   Для каждого успешно обновленного сообщения `DialogService` публикует событие `MessageReadEvent` в RabbitMQ (обменник `message-events`, ключ `message.read`).
    *   `CounterService` подписан на очередь `counter-service-message-read`, привязанную к ключу `message.read`. При получении события он уменьшает счетчик `UnreadMessages` для пользователя (`UserId`) в своей базе данных (`counter-db`).
    *   Аналогично отправке, `CounterService` инвалидирует кэш со списком счетчиков пользователя в Redis.

3.  **Получение счетчика:**
    *   Когда клиенту требуется узнать количество непрочитанных сообщений, он отправляет запрос напрямую в `CounterService` (например, `GET /counters/user/{userId}/UnreadMessages`).
    *   `CounterService` сначала пытается получить значение счетчика из кэша Redis по ключу `counter:{userId}:UnreadMessages`.
    *   Если значение найдено в кэше, оно немедленно возвращается клиенту.
    *   Если значение в кэше отсутствует, `CounterService` запрашивает его из базы данных `counter-db`.
    *   Полученное из БД значение сохраняется в кэше Redis с определенным временем жизни (TTL) и возвращается клиенту.

## 4. Согласованность данных

Используется паттерн **событийной согласованности** (Eventual Consistency). Это означает, что счетчики в `CounterService` обновляются асинхронно после фактической отправки или прочтения сообщения. Возможна кратковременная задержка между действием в `DialogService` и обновлением счетчика. Однако такая архитектура обеспечивает слабую связанность сервисов и лучшую масштабируемость.